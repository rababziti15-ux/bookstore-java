package bookstore.repository;

import bookstore.model.Book;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class InMemoryBookRepository implements BookRepository {

    private final List<Book> books = new ArrayList<>();
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock(); // Advanced thread safety

    // ================= THREAD =================
    @Override
    public synchronized void save(Book book) {
        books.add(book);
    }

    // NEW: Batch save with write lock
    public void saveAll(List<Book> booksToSave) {
        rwLock.writeLock().lock();
        try {
            books.addAll(booksToSave);
            System.out.println("[BATCH SAVE] Added " + booksToSave.size() + " books");
        } finally {
            rwLock.writeLock().unlock();
        }
    }

    // NEW: Update book with write lock
    public boolean updateBook(String isbn, Book updatedBook) {
        rwLock.writeLock().lock();
        try {
            for (int i = 0; i < books.size(); i++) {
                if (books.get(i).getIsbn().equals(isbn)) {
                    books.set(i, updatedBook);
                    return true;
                }
            }
            return false;
        } finally {
            rwLock.writeLock().unlock();
        }
    }

    // ================= STREAM =================
    @Override
    public List<Book> findAll() {
        rwLock.readLock().lock();
        try {
            return books.stream().toList();
        } finally {
            rwLock.readLock().unlock();
        }
    }

    @Override
    public Book findByIsbn(String isbn) {
        rwLock.readLock().lock();
        try {
            Optional<Book> result = books.stream()
                    .filter(b -> b.getIsbn().equals(isbn))
                    .findFirst();
            return result.orElse(null);
        } finally {
            rwLock.readLock().unlock();
        }
    }

    // ================= STREAM + THREAD =================
    @Override
    public synchronized boolean deleteByIsbn(String isbn) {
        return books.removeIf(b -> b.getIsbn().equals(isbn));
    }

    // ================= EXTRA IMPORTANT FUNCTIONS =================

    // Livres disponibles uniquement
    public List<Book> findAvailableBooks() {
        rwLock.readLock().lock();
        try {
            return books.stream()
                    .filter(b -> b.getStock() > 0)
                    .toList();
        } finally {
            rwLock.readLock().unlock();
        }
    }

    // Livre le plus cher
    public Book findMostExpensiveBook() {
        rwLock.readLock().lock();
        try {
            return books.stream()
                    .max((b1, b2) -> Double.compare(b1.getPrice(), b2.getPrice()))
                    .orElse(null);
        } finally {
            rwLock.readLock().unlock();
        }
    }

    // Valeur totale du stock
    public double totalStockValue() {
        rwLock.readLock().lock();
        try {
            return books.stream()
                    .mapToDouble(b -> b.getPrice() * b.getStock())
                    .sum();
        } finally {
            rwLock.readLock().unlock();
        }
    }

    // ================= NEW STREAM OPERATIONS =================

    // NEW: Find cheapest book
    public Book findCheapestBook() {
        rwLock.readLock().lock();
        try {
            return books.stream()
                    .min((b1, b2) -> Double.compare(b1.getPrice(), b2.getPrice()))
                    .orElse(null);
        } finally {
            rwLock.readLock().unlock();
        }
    }

    // NEW: Find books by author
    public List<Book> findBooksByAuthor(String author) {
        rwLock.readLock().lock();
        try {
            return books.stream()
                    .filter(b -> b.getAuthor().equalsIgnoreCase(author))
                    .collect(Collectors.toList());
        } finally {
            rwLock.readLock().unlock();
        }
    }

    // NEW: Find books by price range
    public List<Book> findBooksByPriceRange(double min, double max) {
        rwLock.readLock().lock();
        try {
            return books.stream()
                    .filter(b -> b.getPrice() >= min && b.getPrice() <= max)
                    .sorted((b1, b2) -> Double.compare(b1.getPrice(), b2.getPrice()))
                    .collect(Collectors.toList());
        } finally {
            rwLock.readLock().unlock();
        }
    }

    // NEW: Group books by author
    public Map<String, List<Book>> groupBooksByAuthor() {
        rwLock.readLock().lock();
        try {
            return books.stream()
                    .collect(Collectors.groupingBy(Book::getAuthor));
        } finally {
            rwLock.readLock().unlock();
        }
    }

    // NEW: Count books by price category
    public Map<String, Long> countByPriceCategory() {
        rwLock.readLock().lock();
        try {
            return books.stream()
                    .collect(Collectors.groupingBy(
                        b -> {
                            if (b.getPrice() < 20) return "Budget";
                            else if (b.getPrice() < 40) return "Standard";
                            else return "Premium";
                        },
                        Collectors.counting()
                    ));
        } finally {
            rwLock.readLock().unlock();
        }
    }

    // NEW: Find low stock books
    public List<Book> findLowStockBooks(int threshold) {
        rwLock.readLock().lock();
        try {
            return books.stream()
                    .filter(b -> b.getStock() <= threshold && b.getStock() > 0)
                    .sorted((b1, b2) -> Integer.compare(b1.getStock(), b2.getStock()))
                    .collect(Collectors.toList());
        } finally {
            rwLock.readLock().unlock();
        }
    }

    // NEW: Find out of stock books
    public List<Book> findOutOfStockBooks() {
        rwLock.readLock().lock();
        try {
            return books.stream()
                    .filter(b -> b.getStock() == 0)
                    .collect(Collectors.toList());
        } finally {
            rwLock.readLock().unlock();
        }
    }

    // NEW: Calculate average book price
    public double averageBookPrice() {
        rwLock.readLock().lock();
        try {
            return books.stream()
                    .mapToDouble(Book::getPrice)
                    .average()
                    .orElse(0.0);
        } finally {
            rwLock.readLock().unlock();
        }
    }

    // NEW: Get total books count
    public long getTotalBooksCount() {
        rwLock.readLock().lock();
        try {
            return books.stream()
                    .mapToInt(Book::getStock)
                    .sum();
        } finally {
            rwLock.readLock().unlock();
        }
    }

    // NEW: Find top N expensive books
    public List<Book> findTopExpensiveBooks(int n) {
        rwLock.readLock().lock();
        try {
            return books.stream()
                    .sorted((b1, b2) -> Double.compare(b2.getPrice(), b1.getPrice()))
                    .limit(n)
                    .collect(Collectors.toList());
        } finally {
            rwLock.readLock().unlock();
        }
    }

    // NEW: Search books by title (contains)
    public List<Book> searchByTitle(String keyword) {
        rwLock.readLock().lock();
        try {
            return books.stream()
                    .filter(b -> b.getTitle().toLowerCase().contains(keyword.toLowerCase()))
                    .collect(Collectors.toList());
        } finally {
            rwLock.readLock().unlock();
        }
    }

    // NEW: Get all unique authors
    public List<String> getAllAuthors() {
        rwLock.readLock().lock();
        try {
            return books.stream()
                    .map(Book::getAuthor)
                    .distinct()
                    .sorted()
                    .collect(Collectors.toList());
        } finally {
            rwLock.readLock().unlock();
        }
    }
}
